package Pebbles;import java.io.FileWriter;import java.io.IOException;import java.io.PrintWriter;import java.util.*;import java.util.concurrent.ConcurrentHashMap;public class PebbleGame extends Thread {    private final ConcurrentHashMap<BagEnum, BlackBag> blackBags;    private final ConcurrentHashMap<BagEnum, Bag> whiteBags;    private final Vector<Player> players;    private final Checker checker;    private Player winner;    private Random rng;    private boolean logging = true;    PebbleGame(int numPlayers) {        blackBags = new ConcurrentHashMap<>();        whiteBags = new ConcurrentHashMap<>();        players = new Vector<>(numPlayers);        checker = new Checker();        rng = new Random();    }    public static void main(String[] args) {        PebbleGame pebbleGame;        if (args.length == 1) {            pebbleGame = PebbleGame.createFromFile(args[0]);        } else {            pebbleGame = PebbleGame.createFromInput();        }        for (int i=0; i < pebbleGame.players.capacity(); i++) {            pebbleGame.addPlayer( "player"+i);        }        pebbleGame.start();        try {            pebbleGame.join();        } catch (InterruptedException e) {            currentThread().interrupt();        }        Player winner = pebbleGame.getWinner();        System.out.println(winner.getName() + " won!");    }    private static PebbleGame createFromInput() {        System.out.println("Welcome to the PebbleGame!!\n" +                "You will be asked to enter the number of players.\n" +                "and then for the location of three files in turn containing comma separated integer values for " +                "the pebble weights\nThe Integer values must be strictly positive.\n" +                "The game will then be simulated, and output written to files in this directory.\n");        Scanner input = new Scanner(System.in);        System.out.println("Enter the number of players: ");        int numPlayers = input.nextInt();        input.nextLine();        PebbleGame pebbleGame = new PebbleGame(numPlayers);        for (BagEnum bagEnum : BagEnum.values()) {            System.out.println("Enter file for bag " + bagEnum.name() + ": ");            pebbleGame.loadBag(bagEnum, input.nextLine());        }        return pebbleGame;    }    private static PebbleGame createFromFile(String fileName) {        Scanner input = new Scanner(fileName);        int seed = input.nextInt();        input.nextLine();        boolean logging = input.nextBoolean();        int numPlayers = input.nextInt();        input.nextLine();        PebbleGame pebbleGame = new PebbleGame(numPlayers).setLogging(logging).setRng(new Random(seed));        for (BagEnum bagEnum : BagEnum.values()) {            pebbleGame.loadBag(bagEnum, input.nextLine());        }        return pebbleGame;    }    PebbleGame setLogging(boolean logging) {        this.logging = logging;        return this;    }    PebbleGame setPlayer(int index, Player player) {        try {            players.set(index, player);            return this;        } catch (ArrayIndexOutOfBoundsException e) {            throw new IllegalArgumentException("Can't set a player outside of range: 0-" + (players.size()-1));        }    }    PebbleGame addPlayer(String name) {        addPlayer(new Player(name));        return this;    }    PebbleGame addPlayer(Player player) {        players.add(player);        return this;    }    PebbleGame setWhiteBag(BagEnum bagEnum, Bag bag) {        whiteBags.put(bagEnum, bag);        return this;    }    PebbleGame setBlackBag(BagEnum bagEnum, BlackBag blackBag) {        blackBags.put(bagEnum, blackBag);        return this;    }    PebbleGame loadBag(BagEnum index, String fileName) {        Bag bag = new Bag();        setWhiteBag(index, bag);        setBlackBag(index, BlackBag.fromCSV(bag, players.capacity(), fileName));        return this;    }    @Override    public void run() {        checker.start();        for (Player player : players) {            player.start();        }        for (Player player : players) {            try {                player.join();            } catch (InterruptedException e) {                currentThread().interrupt();            }        }        checker.setFinished(true);        synchronized (checker) {            checker.notifyAll();        }        try {            checker.join();        } catch (InterruptedException e) {            currentThread().interrupt();        }    }    public Random getRng() {        return rng;    }    PebbleGame setRng(Random rng) {        this.rng = rng;        return this;    }    PebbleGame setRng(int rng) {        return setRng(new Random(rng));    }    private Player getWinner() {        return winner;    }    private void setWinner(Player winner) {        if (this.winner == null) {            this.winner = winner;        }    }    Vector<Player> getPlayers() {        return players;    }    private ConcurrentHashMap<BagEnum, BlackBag> getBlackBags() {        return blackBags;    }    private ConcurrentHashMap<BagEnum, Bag> getWhiteBags() {        return whiteBags;    }    class Checker extends Thread {        private volatile boolean finished = false;        Checker() {            super("Checker");        }        @Override        public void run() {            while (!finished) {                synchronized (this) {                    try {                        wait();                    } catch (InterruptedException e) {                        currentThread().interrupt();                    }                }                for (ConcurrentHashMap.Entry<BagEnum, BlackBag> entry : blackBags.entrySet()) {                    BlackBag blackBag = entry.getValue();                    if (blackBag.size() <= 0) {                        blackBag.refill();                    }                }            }        }        synchronized void setFinished(boolean value) {            notifyAll();            finished = value;        }    }    class Player extends ThreadBag {        private volatile Boolean finished = false;        private PrintWriter writer;        private BagEnum lastDraw;        Player(String name) {            super(name);            if (logging) {                try {                    writer = new PrintWriter(new FileWriter(name + "_log.txt"));                } catch (IOException e) {                    e.printStackTrace();                }            }        }        @Override        public void run() {            getStartingStones(getRandomBlackBag());            writer.println(getName() + " starts with: " + showStones() + ", total: " + getTotalWeight());            while (!finished) {                try {                    sleep(100);                } catch (InterruptedException e) {                    currentThread().interrupt();                }                if (getTotalWeight() == 100) {                    stopAll();                    break;                } else {                    ArrayList<BagEnum> attempts = new ArrayList<>(Arrays.asList(BagEnum.values()));                    BagEnum selection;                    BlackBag bBag = null;                    while (attempts.size() > 0) {                        selection = attempts.remove(rng.nextInt(attempts.size()));                        bBag = getBlackBags().get(selection);                        if (bBag.size() > 0) {                            lastDraw = selection;                            Bag wBag = getDiscardBag();                            Integer removedStone = removeStone(rng.nextInt(size()));                            wBag.addStone(removedStone);                            log(getName() + " discard a " + removedStone + ".");                            log(getName() + " hand is: " + showStones());                            Integer addedStone = bBag.removeStone(rng.nextInt(bBag.size()));                            addStone(addedStone);                            log(getName() + " drew a " + addedStone + ".");                            log(getName() + " hand is: " + showStones() + ", total: " + getTotalWeight());                            break;                        }                    }                    if (attempts.size() == 0) {                        assert bBag != null;                        synchronized (bBag) {                            try {                                bBag.wait();                            } catch (InterruptedException e) {                                currentThread().interrupt();                            }                        }                    }                }            }            writer.close();        }        private <T> void log(T val) {            if (writer != null) {                writer.println(val);            }        }        void finish() {            finished = true;        }        private void stopAll() {            setWinner(this);            for (Player player : players) {                player.finish();            }        }        private Integer getTotalWeight() {            Integer total = 0;            for (Integer stone : stones) {                total += stone;            }            return total;        }        private Bag getDiscardBag() {            if (lastDraw != null) {                return getWhiteBags().get(lastDraw);            }            return getWhiteBags().get(randomEnum(BagEnum.class));        }        private BlackBag getRandomBlackBag() {            return getBlackBags().get(randomEnum(BagEnum.class));        }        private void getStartingStones(BlackBag bag) {            synchronized (bag) {                while (bag.size() <= 0) {                    try {                        bag.wait();                    } catch (InterruptedException e) {                        currentThread().interrupt();                    }                }                for (int i=0; i < 10; i++) {                    addStone(bag.removeStone(rng.nextInt(bag.size())));                }            }        }        private <T extends Enum<?>> T randomEnum(Class<T> clazz){            int x = rng.nextInt(clazz.getEnumConstants().length);            return clazz.getEnumConstants()[x];        }    }}